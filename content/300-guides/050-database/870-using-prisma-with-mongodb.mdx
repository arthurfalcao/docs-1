---
title: 'Using Prisma with MongoDB'
metaTitle: 'Using Prisma with MongoDB'
metaDescription: 'Guide to using Prisma with MongoDB'
tocDepth: 2
toc: true
---

<TopBlock>

This guide discusses the concepts behind using Prisma and MongoDB, explains the commonalities and differences between MongoDB and other database providers, and leads you through the process for configuring your application to integrate with MongoDB.

</TopBlock>

## What is MongoDB?

MongoDB is a NoSQL database that stores data in a JSON-like document format.

Features include:

- **Flexible schemas** ...
- **Support for scaling** ...
- ...

## Commonalities with other database providers

Some aspects of using Prisma with MongoDB are the same as when using Prisma with a relational database. You can still:

- model your database with the [Prisma Schema Language](/concepts/components/prisma-schema)
- connect to your database, using the [`mongodb` database connector](/concepts/database-connectors/mongodb)
- use [Introspection](/concepts/components/introspection) for existing projects if you already have a MongoDB database
- use [`db push`](/concepts/components/prisma-migrate/db-push) to push changes in your schema to the database
- use [Prisma Client](/concepts/components/prisma-client) in your application to query your database

## Differences to consider

MongoDB's document-based structure and flexible schemas means that using Prisma with MongoDB differs from using it with a relational database in a number of ways. These are some areas where there are differences you need to be aware of:

**Defining IDs.** MongoDB documents have an `_id` field that contain an [ObjectID](https://www.mongodb.com/docs/manual/reference/bson-types/#std-label-objectid). This needs to be mapped to a Prisma field. For more information, see [Defining IDs in MongoDB](/concepts/components/prisma-schema/data-model#defining-ids-in-mongodb).

**Migrating old data to new schemas.** In relational databases, all your data must match your schema. If you change the type of a particular field in your schema when you migrate, all the data must also be updated to match. In contrast, MongoDB does not enforce
For more information, see [How to migrate old data to new schemas](#how-to-migrate-old-data-to-new-schemas).

**Introspection.** When you introspect an existing database, you will get a schema with no relations and will need to add the missing relations in manually. For more information, see [How to add in missing relations after Introspection](#how-to-add-in-missing-relations-after-introspection).

**Filtering for `null` and undefined fields.** MongoDB makes a distinction between setting a field to `null` and not setting it at all, which is not present in relational databases. Prisma currently does not express this distinction, which means that you need to be careful when filtering for `null` and undefined fields. For more information, see [How to filter for `null` and undefined fields](#how-to-filter-for-null-and-undefined-fields).

**Using a replica set.** Prisma uses [MongoDB transactions](https://www.mongodb.com/docs/manual/core/transactions/) internally to avoid partial writes on nested queries. When using transactions, MongoDB requires you to have a [replica set](https://www.mongodb.com/docs/manual/replication/) configured — this is a group of MongoDB processes that maintain the same data set, providing redundancy and high availability. If you use MongoDB's [Atlas](https://www.mongodb.com/atlas/database) hosting service, the replica set is configured for you, but if you are running MongoDB locally you will need to set this up yourself. For more information, see [How to configure a replica set](#how-to-configure-a-replica-set)

## How to migrate old data to new schemas

## How to add in missing relations after Introspection

## How to filter for <inlinecode>null</inlinecode> and undefined fields

To understand how MongoDB distinguishes between `null` and undefined fields, consider the example of a `User` model with an optional `name` field:

```ts
model User {
  id    String  @id @default(auto()) @map("_id") @db.ObjectId
  email String
  name  String?
}
```

First, try creating a record with the `name` field explicitly set to `null`. Prisma will return `name: null` as expected:

<CodeWithResult expanded={true}>

<cmd>

```ts
const createNull = await prisma.user.create({
  data: {
    email: 'user1@prisma.io',
    name: null,
  },
})
console.log(createNull)
```

</cmd>

<cmdResult>

```
{
    id: '6242c4ae032bc76da250b207',
    email: 'user1@prisma.io',
    name: null
}
```

</cmdResult>

</CodeWithResult>

If you check your MongoDB database directly, you will also see a new record with `name` set to `null`:

```terminal
_id: 6242c4af032bc76da250b207
email: "user1@prisma.io"
name: null
```

Next, try creating a record without explicitly setting the `name` field:

<CodeWithResult expanded={true}>

<cmd>

```ts
  const createUndefined = await prisma.user.create({
    data: {
       email: "user2@prisma.io",
     }
   })
   console.log(createUndefined)
}
```

</cmd>

<cmdResult>

```
{
    id: '6242c4ae032bc76da250b208',
    email: 'user2@prisma.io',
    name: null
},

```

</cmdResult>

</CodeWithResult>

Prisma still returns `name: null`, but if you look in the database directly you will see that the record has no `name` field defined at all:

```terminal
_id: 6242c4af032bc76da250b208
email: "user2@prisma.io"
```

Prisma returns the same result in both cases, because we currently don't have a way to specify this difference in MongoDB between fields that are `null` in the underlying database, and fields that are not defined at all — see [this Github issue](https://github.com/prisma/prisma/issues/12555) for more information.

This means that you currently have to be careful when filtering for `null` and undefined fields. Filtering for records with `name: null` will only return the first record, with the `name` explicitly set to `null`:

<CodeWithResult expanded={true}>

<cmd>

```ts
const findNulls = await prisma.user.findMany({
  where: {
    name: null,
  },
})
console.log(findNulls)
```

</cmd>

<cmdResult>

```terminal
[
  {
    id: '6242c4ae032bc76da250b207',
    email: 'user1@prisma.io',
    name: null
  }
]
```

</cmdResult>

</CodeWithResult>

To include undefined fields as well, use the [`isSet` filter](/reference/api-reference/prisma-client-reference#isset) to explicitly search for fields which are either `null` or not set. This will return both records:

<CodeWithResult expanded={true}>

<cmd>

```ts
const findNullOrUndefined = await prisma.user.findMany({
  where: {
    OR: [
      {
        name: null,
      },
      {
        name: {
          isSet: false,
        },
      },
    ],
  },
})

console.log(findNullOrUndefined)
```

</cmd>

<cmdResult>

```terminal
[
  {
    id: '6242c4ae032bc76da250b207',
    email: 'user1@prisma.io',
    name: null
  },
  {
    id: '6242c4ae032bc76da250b208',
    email: 'user2@prisma.io',
    name: null
  }
]
```

</cmdResult>

</CodeWithResult>

## How to configure a replica set

## More on using MongoDB with Prisma

The fastest way to start using MongoDB with Prisma is to refer to our Getting Started documentation:

- [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb)
- [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb)

These tutorials will take you through the process of connecting to MongoDB, pushing schema changes, and using the Prisma Client.
